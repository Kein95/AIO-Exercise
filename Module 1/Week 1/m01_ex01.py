# -*- coding: utf-8 -*-
"""M01_EX01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y2MFr-RbPJGKDHA85QqzeUrE7x5rC7xz
"""

# Import libraries
import math
import random

"""1. Viết function thực hiện đánh giá classification model bằng F1-Score."""

def evaluate_classification_model(tp, fp, fn):
    # Kiểm tra các giá trị đầu vào
    if not all(isinstance(i, int) for i in [tp, fp, fn]):
        print("tp, fp, and fn must be int")
        return

    if tp <= 0 and fp <= 0 and fn <= 0:
        print("tp and fp and fn must be greater than zero")
        return

    # Tính toán Precision, Recall và F1-Score
    precision = tp / (tp + fp)
    recall = tp / (tp + fn)
    f1_score = 2 * (precision * recall) / (precision + recall)

    # In kết quả
    print("Precision:", precision)
    print("Recall:", recall)
    print("F1-Score:", f1_score)

evaluate_classification_model(2, 4, 5)

"""2. Viết function mô phỏng theo 3 activation function."""

def is_number ( x ) :
  try :
    float ( x )
    return True
  except ValueError :
    return False

def activation_function(x, activation_name):
  # Kiểm tra x có hợp lệ hay không
  if not is_number(x):
    print("x must be a number")
    return
  # Kiểm tra tên activation function
  match activation_name:
    case 'sigmoid':
      return 1 / (1 + math.exp(-x))
    case 'relu':
      return max(0, x)
    case 'elu':
      return x if x>0 else 0.01 * (math.exp(x)-1)
    case _:
      print(f"{activation_name} is not supported")




activation_function('abc', 'sigmoid')

activation_function(1.5,'belu')

activation_function(2, 'relu')

"""3. Viết function lựa chọn regression loss function để tính loss"""

import math
import random

def calculate_mae(predicts, targets):
  return sum(abs(predict - target) for predict, target in zip(predicts, targets)) / len(predicts)

def calculate_mse(predicts, targets):
  return sum((predict - target) ** 2 for predict, target in zip(predicts, targets)) / len(predicts)

def rmse(predictions, targets):
  return math.sqrt(calculate_mse(predictions, targets))

def calculate_loss(num_samples):
    # Người dùng nhập số lượng sample (num_samples) được tạo ra (chỉ nhận integer numbers)
    if not str(num_samples).isdigit() or int(num_samples) <= 0:
        print("number of samples must be an integer number")

    #  Người dùng nhập loss name (MAE, MSE, RMSE-(optional)) chỉ cần MAE và MSE, bạn nào muốn làm thêm RMSE đều được.

"""4. Viết 4 functions để ước lượng các hàm số sau."""

# Tính giai thừa
def factorial(n):
    if n == 0:
        return 1
    result = 1
    for i in range(1, n+1):
        result *= i
    return result

factorial(3)

# Tính sin, cos, sinh, cosh
import math

def sin(x, n):
    result = 0
    for i in range(n):
        result += ((-1)**i) * (x**(2*i + 1)) / factorial(2*i + 1)
    return result

def cos(x, n):
    result = 0
    for i in range(n):
        result += ((-1)**i) * (x**(2*i)) / factorial(2*i)
    return result

def sinh(x, n):
    result = 0
    for i in range(n):
        result += (x**(2*i + 1)) / factorial(2*i + 1)
    return result

def cosh(x, n):
    result = 0
    for i in range(n):
        result += (x**(2*i)) / factorial(2*i)
    return result

print(sin (x = 3.14, n = 10))
print(cos (x = 3.14, n = 10))
print(sinh (x = 3.14, n = 10))
print(cosh (x = 3.14, n = 10))

"""5. Viết function thực hiện Mean Difference"""

def md_nre_single_calculate(y, y_hat, n, p):
    _y = float(y)
    _y_hat = float(y_hat)
    _n = float(n)
    _p = float(p)

    md = (_y ** (1 / _n)) - (_y_hat ** (1 / _n)) ** _p
    return print(md)

md_nre_single_calculate(100,99.5,2,1)
